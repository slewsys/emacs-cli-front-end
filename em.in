#!/usr/bin/env bash
#
# -*- coding: utf-8 -*-
#
# Copyright Â© 2023 Andrew L. Moore
#
# This script runs emacs(1) and/or emacsclient(1) as appropriate per
# given command-line arguments. For interactive sessions, emacs(1) is
# started in daemon mode as necessary prior to running emacsclient(1).
#
# Invoking this script with multiple FILE arguments by default opens
# FILEs in the top-most frame either sequentially, via the
# `server-edit' (C-x #) command, or randomly, via `switch-to-buffer'
# (C-x b).
#
# In addition to command-line options from emacs(1) and emacsclient(1),
# the following options are recognized:
#
#   --buffer [BUF]           Visit buffer BUF if given, otherwise `*scratch*'.
#   --dired [DIR]            Visit directory DIR if given, otherwise `.'.
#   --many-frames            Visit FILEs in parallel, each in its own frame.
#   --markdown, -md FILE     Visit FILE in mode \`markdown-live-preview-mode'.
#   --new-frame, -new        Visit FILEs in a new frame.
#   --preload-files, -pr     Load FILEs in parallel, but visit one at a time.
#   --save-kill, -sa         Save buffers and kill Emacs and Emacs server.
#   --ssh [USER@]HOST[:PATH] Visit PATH on remote HOST via SSH. If PATH not
#                            given, visit USER's home directory on HOST.
#   --ssu [USER@]HOST[:PATH] Visit PATH with SUDO on remote HOST via SSH.
#                            If PATH not given, visit USER's home directory
#                            on HOST.
#   --sudo [USER]            If USER is specified, visit files as USER
#                            via tramp. Otherwise, visit files as \`root'.
#   --trace                  Trace execution of $pgm(1) script.
#   --two-way-merge, -tw FILE1,FILE2[,OUTPUT-FILE]
#                            Call \`emerge-files' with arguments FILE1 and
#                            FILE2.  Save output to OUTPUT-FILE if given.
#   --update-loaddefs[=DIR]  Build DIR-loaddefs.el.
#   --view, -vi FILE        Open FILE in read-only mode.
#   --wait                   Run emacsclient in foreground.
#
# Options may be abbreviated (e.g., `-new' instead of `--new-frame')
# provided they are unambiguous.
#
# If this script is invoked with either no command-line options or
# emacsclient options only, then it runs as a background process and
# switches focus to the Emacs server. Otherwise, Emacs-specific
# command-line options (see `emacs --help') force a new Emacs process
# to be run in the foreground, allowing this script to be invoked,
# e.g., in batch mode within a Makefile.
#
# If the environment variable SSH_TTY is set, and the ssh client and server
# differ, then `--tty' command-line option is enabled by default.
#
shopt -s extglob

: ${AWK_CMD:='@AWK_CMD@'}
: ${BASENAME_CMD:='@BASENAME_CMD@'}
: ${DIRNAME_CMD:='@DIRNAME_CMD@'}
: ${ED_CMD:='@ED_CMD@'}
: ${GREP_CMD:='@GREP_CMD@'}
: ${_EMACS_CMD:='@EMACS_CMD@'}
: ${_EMACSCLIENT_CMD:='@EMACSCLIENT_CMD@'}
: ${FIND_CMD:='@FIND_CMD@'}
: ${HEAD_CMD:='@HEAD_CMD@'}
: ${ID_CMD:='@ID_CMD@'}
: ${KILL_CMD:='@KILL_CMD@'}
: ${MKDIR_CMD:='@MKDIR_CMD@'}
: ${MKTEMP_CMD:='@MKTEMP_CMD@'}
: ${OSASCRIPT_CMD:='@OSASCRIPT_CMD@'}
: ${PKILL_CMD:='@PKILL_CMD@'}
: ${PS_CMD:='@PS_CMD@'}
: ${READLINK_CMD:='@READLINK_CMD@'}
: ${RM_CMD:='@RM_CMD@'}
: ${SED_CMD:='@SED_CMD@'}
: ${SLEEP_CMD:='@SLEEP_CMD@'}
: ${SORT_CMD:='@SORT_CMD@'}
: ${STAT_CMD:='@STAT_CMD@'}
: ${TOUCH_CMD:='@TOUCH_CMD@'}
: ${TTY_CMD:='@TTY_CMD@'}
: ${UNAME_CMD:='@UNAME_CMD@'}
: ${WMCTRL_CMD:='@WMCTRL_CMD@'}

usage ()
{
    $ED_CMD -v <<EOF
a
$($_EMACSCLIENT_CMD --help)
.
1s;Usage: [^ ]\{1,\};Usage: $script_name;
# Option \`-f' is shadowed by Emacs option \`--funcall'
/-f SERVER, /s;;;
.,+j
s;\(SERVER\).*\(Set\);\1    \2;
\$-1c

Extended options:

--buffer [BUF]           Visit buffer BUF if given, otherwise \`*scratch*'.
--dired [DIR]            Visit directory DIR if given, otherwise \`.'.
--many-frames            Visit FILEs in parallel, each in its own frame.
--markdown, -md FILE     Visit FILE in mode \`markdown-live-preview-mode'.
--new-frame              Visit FILEs in a new frame.
--preload-files          Load FILEs in parallel, but visit one at a time.
--save-kill, -sa         Save buffers and kill Emacs and Emacs server.
--ssh [USER@]HOST[:PATH] Visit PATH on remote HOST via SSH. If PATH not
                         given, visit USER's home directory on HOST.
--ssu [USER@]HOST[:PATH] Visit PATH with SUDO on remote HOST via SSH.
                         If PATH not given, visit USER's home directory.
--sudo [USER]            If USER is specified, visit files as USER
                         via tramp. Otherwise, visit files as \`root'.
--trace                  Trace execution of $script_name(1) script.
--two-way-merge, -tw FILE1,FILE2[,OUTPUT-FILE]
                         Call \`emerge-files' with arguments FILE1 and FILE2.
                         Save output to OUTPUT-FILE if given.
--update-loaddefs [DIR]  Build DIR-loaddefs.el from DIR/*.el.
--view, -vi FILE         Visit FILE in read-only mode.
--wait                   Run emacsclient in foreground.

In addition to the above, the following Emacs-specific options are
recognized. Most of these cannot be processed by an existing Emacs
server, in which case a separate Emacs process is invoked.

.
# Mark last line of \`emacsclient --help'.
\$kx
\$a
$($_EMACS_CMD --help)
.
# Remove head of \`emacs --help'.
'x+;/options:/-d
s/.*options:\$/Emacs &/
# Remove shadowed options
/-q, --quiet/s;;--quiet    ;
?--display?d
/--terminal/s;, -t DEVICE; DEVICE    ;
/, -nw/s;;     ;
# Remove tail of \`emacs --help'.
\$;?--parent?;\$--d
# Merge last lines of \`emacsclient --help' and \`emacs --help'.
'xm\$--
s;\\.\$;, or alternatively,;
i

.
,p
Q
EOF
}

# Check shell interpreter version.
is-supported-shell ()
{
    # $BASH_VERSION prerequisites (want: option `-n')
    local -i BASH_MAJOR_PREREQ=4
    local -i BASH_MINOR_PREREQ=3
    local -i BASH_REVISION_PREREQ=0

    if test ."$BASH_VERSION" = .''; then
        echo "$script_name: Bash shell required." >&2
        return 1
    elif (( ${BASH_VERSINFO[0]} < BASH_MAJOR_PREREQ )) ||
             (( ${BASH_VERSINFO[0]} == BASH_MAJOR_PREREQ &&
                      ${BASH_VERSINFO[1]} < BASH_MINOR_PREREQ )) ||
             (( ${BASH_VERSINFO[0]} == BASH_MAJOR_PREREQ &&
                      ${BASH_VERSINFO[1]} == BASH_MINOR_PREREQ &&
                      ${BASH_VERSINFO[2]} < BASH_REVISION_PREREQ )); then
        echo "$script_name: $BASH_VERSION: Newer Bash shell required." >&2
        return 1
    fi
    return 0
}

# OS-agnstoic readlink for existent files/directories.
resolve-existing ()
{
    if $READLINK_CMD --version 2>&1 | $GREP_CMD -q 'coreutils'; then
        $READLINK_CMD -e "$@"
    else
        $READLINK_CMD -f N "$@"
    fi
}

verify-command-paths ()
{
    local -n list=$1

    local -i status=0
    local cmd

    for cmd in "${list[@]}"; do
        if eval test .\"\$$cmd\" = .''; then
            echo "${BASH_SOURCE[0]}: $cmd: Undefined variable" >&2
            (( ++status ))
        elif eval test ! -x \"\$$cmd\"; then
            eval echo "${BASH_SOURCE[0]}: \$$cmd: No such command" >&2
            (( ++status ))
        fi
    done
}

# Check command paths.
is-valid-environment ()
{
    local -i status=0
    local -a command_variables=(
        $($SED_CMD -nE -e '/^:\s\$\{([A-Z_][A-Z0-9_]*):.*/s//\1/p' "$0")
    )

    verify-command-paths command_variables
    unset -v command_variables

    return $status
}

# Check Emacs version.
is-current-emacs ()
{
    local -i EMACS_MAJOR_PREREQ=25
    local -i status=0
    local emacs_version

    for editor in _EMACS_CMD _EMACSCLIENT_CMD; do
        emacs_version=$(
            ${!editor} --version |
                $HEAD_CMD -1 |
                $AWK_CMD '{ print $NF }'
                  )
        if (( ${emacs_version%%.*} < EMACS_MAJOR_PREREQ )); then
            echo "$script_name: $emacs_version: Newer ${!editor} required." >&2
            status+=1
        fi
    done
    return $status
}

is-running-emacs ()
{
    case "$OSTYPE" in
        darwin*)
            $PKILL_CMD -0 -u "$user_id" -f                                       \
                       "${_EMACS_CMD##*/}.*daemon=.*${server_name} " >/dev/null 2>&1
            ;;
        *)
            $PKILL_CMD -0 -u "$user_id" -f                                       \
                       "${_EMACS_CMD##*/}.*daemon=.*${server_name}\\b" >/dev/null 2>&1
            ;;
    esac
}

is-running-emacsclient ()
{
    case "$OSTYPE" in
        darwin*)
            $PKILL_CMD -0 -u "$user_id" -f                                       \
                       "${_EMACSCLIENT_CMD##*/}.*${server_name} " >/dev/null 2>&1
            ;;
        *)
            $PKILL_CMD -0 -u "$user_id" -f                                       \
                       "${_EMACSCLIENT_CMD##*/}.*${server_name}\\b" >/dev/null 2>&1
            ;;
    esac
}

create-frame-or-tty ()
{
    if test ."$_EMACSCLIENT_CMD" != ."$_EMACS_CMD"; then
        if ! is-running-emacsclient || $create_new_frames; then
            echo $frame_or_tty
        fi
    elif test ."$frame_or_tty" != .'--create-frame'; then
        echo $frame_or_tty
    fi
}

configure-for-console ()
{
    # No frames, by default.
    preload_files=false
    create_new_frames=false
    create_many_new_frames=false
    frame_or_tty=-nw

    # Provide default Emacs server name.  Overriden by option `-s'.
    server_name=server_${user_name}_${tty_name##*/}

    # Run in foreground.
    background_op=''
}

# Set up environment for Emacs, as opposed to emacsclient.
switch-to-emacs ()
{
    # Run in foreground.
    background_op=''

    # Report exit codes (see function `raise-exception' below).
    error_diagnostic='Emacs: Exited with error: $error_status'
}

raise-exception ()
{
    error_status=$?
    echo "Exception raised in: $@" >&3
    eval printf \"$script_name: $error_diagnostic\\n\" >&3
    if test -s "$stderr_cache"; then
        printf "%s\n" "$(< "$stderr_cache" )" >&3
    fi
    exit $error_status
}

start-emacs-server ()
{
    local -i i=0
    local first_diag=true
    local server_socket_dir

    server_socket_dir=$(
        $_EMACS_CMD --batch -q  \
                  --eval "(progn (server-start) (prin1 server-socket-dir))"
                          )
    if test ."$server_socket_dir" = .''; then
        server_socket_dir=${TMPDIR:-'/tmp'}
    fi

    echo -n "Launching Server... " >&3

    # Removing any left-over socket
    if test -d "$server_socket_dir"; then
        $FIND_CMD "$server_socket_dir" -type s 2>/dev/null |
            while read socket; do
                if test ."${socket##*/}" = ."$server_name"; then
                    $RM_CMD -f "$socket"
                fi
            done
    fi

    $_EMACS_CMD --daemon="$server_name"                                         \
                >"${emacs_confdir}/${server_name}.log" 2>&1 &
    wait $! ||
        raise-exception 'server start'

    # Verify that server is accessible via emacsclient(1).
    $_EMACSCLIENT_CMD -s "$server_name" --no-wait --eval 't' >/dev/null ||
        raise-exception 'server access'

    # Print Emacs startup errors/warnings to console.
    $GREP_CMD -E -iA 7 'warning|error' "${emacs_confdir}/${server_name}.log" |
        while read diag; do
            if $first_diag; then
                echo >&3
                first_diag=false
            fi
            echo "$diag" >&3
        done
}

tty-owner-id ()
{
    if $STAT_CMD --version | $GREP_CMD -q 'coreutils'; then

        # GNU stat...
        stat_flag=-c
    else

        # BSD stat
        stat_flag=-f
    fi

    $STAT_CMD "${stat_flag}" '%u' "$tty_name"
}

# Parse command-line options for requests.
parse-options ()
{
    local buffer=''
    local directory=''
    local editor=''
    local file=''
    local files=''
    local file1=''
    local file2=''
    local file3=''
    local username=''
    local remotehost=''
    local pathname=''

    # Aggregate options
    while true; do
        case "$1" in

            # Ignore alternate editor
            -a*|--a*)
                # EDITOR given as --alternate-editor=EDITOR
                if [[ ."$1" =~ \.[^=]*=(.*) ]]; then
                    editor=${BASH_REMATCH[1]}
                    OPTIND+=1
                    shift

                    # EDITOR given as second, possibly null, argument.
                else
                    editor=$2
                    OPTIND+=$(( $# == 1 ? 1 : 2 ))
                    shift $(( $# == 1 ? 1 : 2 ))
                fi
                ;;

            # Extension option `--buffer [BUF]'; open buffer BUF.
            --bu*|-bu*)
                argv[argc++]='--eval'

                # BUFFER given as --buffer=BUFFER
                if [[ ."$1" =~ \.[^=]*=(.*) ]]; then
                    buffer=${BASH_REMATCH[1]}
                    OPTIND+=1
                    shift

                # BUFFER given as second, possibly null, argument.
                else
                    buffer=$2
                    OPTIND+=$(( $# == 1 ? 1 : 2 ))
                    shift $(( $# == 1 ? 1 : 2 ))
                fi

                argv[argc]='(switch-to-buffer '
                argv[argc]+="(if (fboundp 'buffer-name-matching-pattern) "
                argv[argc]+='(buffer-name-matching-pattern "'
                argv[argc]+=${buffer:-'\\*scratch\\*'}
                argv[argc]+='") "'
                argv[argc]+=$(printf '%q' "${buffer:-'*scratch*'}")
                argv[argc++]+='"))'
                ;;

            # Extension option `--dired [DIR]'; open DIR in dired mode.
            --dired*|-dired*)
                argv[argc++]='--eval'

                # DIR given as --dired=DIR
                if [[ ."$1" =~ \.[^=]*=(.*) ]]; then
                    directory=${BASH_REMATCH[1]}
                    OPTIND+=1
                    shift

                # DIR given as second, possibly null, argument.
                else
                    directory=$2
                    OPTIND+=$(( $# == 1 ? 1 : 2 ))
                    shift $(( $# == 1 ? 1 : 2 ))
                fi

                # If DIR null, default to current directory.
                argv[argc]='(dired "'
                argv[argc]+=$(printf '%q' "${directory:='.'}")
                argv[argc++]+='")'
                ;;

            # Extension option `--many-frames'; visit files in
            # parallel, each in its own frame.
            --man*|-man*)
                preload_files='true'
                create_new_frames='true'
                create_many_new_frames='true'
                frame_or_tty='--create-frame'
                OPTIND+=1
                shift
                ;;

            # Extension option `--markdown FILE': open FILE in mode
            # `markdown-live-preview-mode'.
            --mar*|-md)
                argv[argc++]='--eval'

                # FILE given as --markdown=FILE
                if [[ ."$1" =~ \.[^=]*=(.*) ]]; then

                    # Need eval in case of argument like `~/file'.
                    file=$(eval resolve-existing "${BASH_REMATCH[1]}")
                    if test ."$file" = .''; then
                        echo "${BASH_REMATCH[1]}: No such file or directory"
                        exit 1
                    fi
                    OPTIND+=1
                    shift

                # FILE given as second, possibly null, argument.
                else
                    file=$(resolve-existing "$2")
                    if test ."$file" = .''; then
                        echo "$2: No such file or directory"
                        exit 1
                    fi
                    OPTIND+=$(( $# == 1 ? 1 : 2 ))
                    shift $(( $# == 1 ? 1 : 2 ))
                fi

                # Open FILE, invoke `markdown-live-preview-mode'.
                argv[argc]='(with-current-buffer '
                argv[argc]+='(find-file "'
                argv[argc]+=$(printf '%q' "${file:='*.md'}")
                argv[argc]+='") '
                argv[argc]+="(unless (eq major-mode 'markdown-mode)"
                argv[argc]+='  (markdown-mode)) '
                argv[argc]+='(markdown-live-preview-mode 1) '
                argv[argc++]+='(delete-other-windows))'
                ;;

            # Extension option `--new-frame'; visit file in new frame.
            --new*|-new*)
                preload_files='false'
                create_new_frames='true'
                create_many_new_frames='false'
                frame_or_tty='--create-frame'
                OPTIND+=1
                shift
                ;;

            # Extension option `--preload'; load files in parallel.
            --pr*|-pr*)
                preload_files='true'
                OPTIND+=1
                shift
                ;;

            # Extension option `--save-kill'.
            --sa*|-sa*)
                argv[argc++]='--eval'
                argv[argc++]='(save-buffers-kill-emacs)'
                allow_server_start='false'
                emacs_verify_kill='true'
                OPTIND+=1
                shift
                ;;


            # Extension option `--ssh [USER@]HOST[:PATHNAME]': open
            # remote PATHNAME via SSH. If USER is nil, use
            # $USER. If PATHNAME is nil, open USER's home
            # directory on HOST.
            --ssh|-ssh)
                argv[argc++]='--eval'
                argv[argc]='(find-file "/ssh:'

                if [[ ."$1" =~ \.[^=]+=([^@[:blank:]]*@)?([^@:[:blank:]]+:?)(.+)?$ ]]; then
                    username=${BASH_REMATCH[1]%@}
                    if test ."$username" != .''; then
                        argv[argc]+=$(printf '%q@' "$username")
                    fi
                    remotehost=${BASH_REMATCH[2]%:}
                    argv[argc]+=$(printf '%q:' "$remotehost")
                    pathname=${BASH_REMATCH[3]:-'.'}
                    if test ."$pathname" != .''; then
                        argv[argc]+=$(printf '%q' "$pathname")
                    fi
                    OPTIND+=1
                    shift
                elif [[ ."$2" =~ \.([^@[:blank:]]*@)?([^@:[:blank:]]+:?)(.+)?$ ]]; then
                    username=${BASH_REMATCH[1]%@}
                    if test ."$username" != .''; then
                        argv[argc]+=$(printf '%q@' "$username")
                    fi
                    remotehost=${BASH_REMATCH[2]%:}
                    argv[argc]+=$(printf '%q:' "$remotehost")
                    pathname=${BASH_REMATCH[3]:-'.'}
                    if test ."$pathname" != .''; then
                        argv[argc]+=$(printf '%q' "$pathname")
                    fi
                    OPTIND+=2
                    shift 2
                else
                    raise-exception "parse-options: Invalid SSH argument"
                fi
                argv[argc++]+='")'
                ;;


            # Extension option `--ssudo [USER@]HOST[:PATHNAME]': open
            # remote PATHNAME via SSH then invoke sudo. If USER is nil, use
            # $USER. If PATHNAME is nil, open USER's home
            # directory on HOST.
            --ssu*|-ssu*)
                argv[argc++]='--eval'
                argv[argc]='(find-file "/ssh:'

                if [[ ."$1" =~ \.[^=]+=([^@[:blank:]]*@)?([^@:[:blank:]]+:?)(.+)?$ ]]; then
                    username=${BASH_REMATCH[1]%@}
                    if test ."$username" != .''; then
                        argv[argc]+=$(printf '%q@' "$username")
                    fi
                    remotehost=${BASH_REMATCH[2]%:}
                    argv[argc]+=$(printf '%q|' "$remotehost")
                    argv[argc]+='sudo:root@'
                    argv[argc]+=$(printf '%q:' "$remotehost")
                    pathname=${BASH_REMATCH[3]:-'.'}
                    if test ."$pathname" != .''; then
                        argv[argc]+=$(printf '%q' "$pathname")
                    fi
                    OPTIND+=1
                    shift
                elif [[ ."$2" =~ \.([^@[:blank:]]*@)?([^@:[:blank:]]+:?)(.+)?$ ]]; then
                    username=${BASH_REMATCH[1]%@}
                    if test ."$username" != .''; then
                        argv[argc]+=$(printf '%q@' "$username")
                    fi
                    remotehost=${BASH_REMATCH[2]%:}
                    argv[argc]+=$(printf '%q|' "$remotehost")
                    argv[argc]+='sudo:root@'
                    argv[argc]+=$(printf '%q:' "$remotehost")
                    pathname=${BASH_REMATCH[3]:-'.'}
                    if test ."$pathname" != .''; then
                        argv[argc]+=$(printf '%q' "$pathname")
                    fi
                    OPTIND+=2
                    shift 2
                else
                    raise-exception "parse-options: Invalid SSH argument"
                fi
                argv[argc++]+='")'
                ;;


            # Extension option `--sudo'; with super-user
            # privileges via tramp.
            --sud*|-sud*)

                # USER given as --sudo=USER
                if [[ ."$1" =~ \.[^=]*=(.*) ]]; then
                    sudo_user=${BASH_REMATCH[1]}
                else
                    sudo_user='root'
                fi
                sudo_user_prefix="/sudo:${sudo_user}@localhost:"
                OPTIND+=1
                shift
                ;;

            # Extension option `--trace'.
            --trac*|-trac*)
                OPTIND+=1
                shift

                # Any prerequisites not met...
                if ! is-supported-shell ||
                        ! is-valid-environment ||
                        ! is-current-emacs; then
                    exit $?
                fi

                enable_trace='true'
                trap ': Line \#"$LINENO"' debug
                set -x
                ;;

            # Extension option `--two-way-merge=FILE1,FILE1[,OUTPUT-FILE]':
            # open FILEs via Emacs function `emerge-files'.
            --tw*|-tw*)
                argv[argc++]='--eval'

                # FILEs given as --two-way-merge=FILE1,FILE2[,OUTPUT-FILE]
                if [[ ."$1" =~ \.[^=]*=([^[:space:]]{1,}) ]]; then
                    files=${BASH_REMATCH[1]}

                    # Need eval in case of argument like `~/file'.
                    file1=$(eval resolve-existing "${files%%,*}")
                    if test ."$file1" = .''; then
                        echo "${files%%,*}: No such file or directory"
                        exit 1
                    fi

                    files=${files#*,}

                    # Need eval in case of argument like `~/file'.
                    file2=$(eval resolve-existing "${files%%,*}")
                    if test ."$file2" = .''; then
                        echo "${files%%,*}: No such file or directory"
                        exit 1
                    elif test ."$file2" != ."$files"; then

                        # Need eval in case of argument like `~/file'.
                        eval file3=${files#*,}
                        if [[ ! ."$file3" =~ ^\./ ]]; then

                            # Since file3 need not exist, resolve-existing
                            # may not work on it.
                            file3=$(resolve-existing '.')/${file3}
                        fi
                    fi
                    OPTIND+=1
                    shift

                # FILEs given as second and third, possibly null, arguments.
                else
                    file1=$(resolve-existing "$2")
                    if test ."$file1" = .''; then
                        echo "$2: No such file or directory"
                        exit 1
                    fi
                    file2=$(resolve-existing "$3")
                    if test ."$file2" = .''; then
                        echo "$3: No such file or directory"
                        exit 1
                    fi
                    OPTIND+=$(( $# > 2 ? 3 : ( $# > 1 ? 2 : 1 ) ))
                    shift $(( $# > 2 ? 3 : ( $# > 1 ? 2 : 1 ) ))
                fi

                # Eval `emerge-files' on FILEs.
                argv[argc]='(emerge-files '
                if test ."$file3" != .''; then
                    argv[argc]+='nil "'
                else
                    argv[argc]+='1 "'
                fi
                argv[argc]+=$(printf '%q' "$file1")
                argv[argc]+='" "'
                argv[argc]+=$(printf '%q' "$file2")
                if test ."$file3" != .''; then
                    argv[argc]+='" "'
                    argv[argc]+=$(printf '%q' "$file3")
                    argv[argc]+='" '
                else
                    argv[argc]+='" nil '
                fi
                argv[argc]+="(and (fboundp 'frame-size-ediff) "
                argv[argc]+="     'frame-size-ediff) "
                argv[argc]+="(and (fboundp 'frame-size-default) "
                argv[argc++]+="   'frame-size-default))"
                ;;

            # Extension option `--update-loaddefs [DIR]'
            --up*|-up*)
                argv[argc++]='-batch'
                argv[argc++]='-q'
                argv[argc++]='--eval'

                # DIR given as --update-loaddefs=DIR
                if [[ ."$1" =~ \.[^=]*=(.*) ]]; then
                    directory=${BASH_REMATCH[1]}
                    OPTIND+=1
                    shift

                # DIR given as second, possibly null, argument.
                else
                    directory=$2
                    OPTIND+=$(( $# == 1 ? 1 : 2 ))
                    shift $(( $# == 1 ? 1 : 2 ))
                fi

                if test ."$directory" = .''; then
                    directory='.'
                fi

                directory=$(resolve-existing "$directory")

                # Prefix autoload filename with last element of $directory path.
                loaddefs=$($BASENAME_CMD "$directory")
                loaddefs+='-loaddefs.el'

                # Update directory autoloads to `$(basename DIR)-loaddefs.el'.
                argv[argc]='(let ((generated-autoload-file "'
                argv[argc]+=$(printf '%q' "${directory}/${loaddefs}")
                argv[argc]+='")) '
                argv[argc]+='(update-directory-autoloads "'
                argv[argc]+=$(printf '%q' "$directory")
                argv[argc++]+='"))'

                # Emacs-specific argument, so invoke emacs(1).
                _EMACSCLIENT_CMD=$_EMACS_CMD
                ;;

            # Extension option `--view'.
            --vie*|-vi*)
                argv[argc++]='--eval'
                argv[argc]='(view-file "'

                if [[ ."$1" =~ ^\.[^=]+=(.*) ]]; then
                    argv[argc]+=${BASH_REMATCH[1]//\"/}
                    OPTIND+=1
                    shift

                # OPTARG given as second, possibly null, argument.
                else
                    argv[argc]+=$2
                    OPTIND+=$(( $# == 1 ? 1 : 2 ))
                    shift $(( $# == 1 ? 1 : 2 ))
                fi
                argv[argc++]+='")'
                ;;

            # Extension option `--wait'
            --wa*|-w*)
                background_op=''
                OPTIND+=1
                shift
                ;;

            # Short version of Emacsclient option `--suppress-output',  `-u',
            # shadows short version of Emacs option `--user' option.
            -u|-supp*|--supp*)
                argv[argc++]=$1
                OPTIND+=1
                shift
                ;;

            # Short version of Emacs option `--funcall', `-f', shadows
            # short version of Emacsclient option `--server-file'.
            #
            # Short version of Emacsclient option `--tramp', `-T',
            # shadows short version of Emacs option `--title'.
            --bac*|-bac*|-bg|--bg-*|-bg-*|                                    \
                --bo*|-bo*|-bd|-bw|                                           \
                --ch*|-ch*|--co*|-co*|--cu*|-cu*|-cr|                         \
                --da*|-da*|--di*|-di*|--du*|-du*|-d|                          \
                --fi[nl]*|-fi[nl]*|--fo[nr]*|-fo[nr]*|-fn|-fg|                \
                --fg-*|-fg-*|-F|--fun*|-fun*|-f|                              \
                --g*|-g*|-ib|--in[ist]*|-in[ist]*|                            \
                -L|--l[oi]*|-l[oi]*|-lsp|-l|                                  \
                --mou*|-mou*|-ms|--na*|-na*|                                  \
                --pa*|-pa*|--sc*|-sc*|--se*|-se*|                             \
                --t[ei]*|-t[ei]*|-t|                                          \
                --u*|-us*|--vi*|-vi*|--xr*|-xr*)

                # OPTARG given as --opt=OPTARG.
                if [[ ."$1" =~ \.([^=]*)=(.*) ]]; then
                    argv[argc++]=${BASH_REMATCH[1]}
                    argv[argc++]=${BASH_REMATCH[2]}
                    OPTIND+=1
                    shift

                # OPTARG given as second, possibly null, argument.
                else
                    argv[argc++]=$1
                    argv[argc++]=$2
                    OPTIND+=$(( $# == 1 ? 1 : 2 ))
                    shift $(( $# == 1 ? 1 : 2 ))
                fi

                # Emacs-specific argument, so invoke Emacs.
                _EMACSCLIENT_CMD=$_EMACS_CMD
                ;;

            # emacslcient options `-s', `--socket-name',
            # `-T', `--tramp'.
            #
            # As noted above, short version of Emacsclient option
            # `--tramp', `-T', shadows by short version of Emacs
            # option `--title'.
            --so*|-so*|-s|--tr*|-T)

                # OPTARG given as --opt=OPTARG.
                if [[ ."$1" =~ \.([^=]*)=(.*) ]]; then
                    argv[argc++]=${BASH_REMATCH[1]}
                    argv[argc++]=${BASH_REMATCH[2]}
                    server_name=${BASH_REMATCH[2]}
                    OPTIND+=1
                    shift

                # OPTARG given as second, possibly null, argument.
                else
                    argv[argc++]=$1
                    argv[argc++]=$2
                    server_name=$2
                    OPTIND+=$(( $# == 1 ? 1 : 2 ))
                    shift $(( $# == 1 ? 1 : 2 ))
                fi
                ;;

            # emacsclient option `--no-wait'.
            --no-wa*|-n)
                argv[argc++]=$1
                OPTIND+=1
                shift
                ;;

            # Emacs option `-q' shadows emacsclient short `--quiet' option.
            --bas*|-bas*|-D|                                                  \
                --bat*|-bat*|                                                 \
                --ful*|-ful*|-fh|-fs|-fw|                                     \
                --ic*|-ic*|--max*|-max*|-mm|--mod*|-mod*|                     \
                --no-*|-no-*|-nbc|-nbi|-nl|-nsl|-q|                           \
                --qu*|-qu*|-Q|                                                \
                --re*|-r|-rv|                                                 \
                --ve*|-ve*|-vb|-x)
                argv[argc++]=$1
                OPTIND+=1
                shift

                # Emacs-specific argument, so invoke Emacs.
                _EMACSCLIENT_CMD=$_EMACS_CMD
                ;;

            # emacsclient option `--create-frame'.
            --cr*|-cr*|-c)
                preload_files='false'
                create_new_frames='true'
                create_many_new_frames='false'
                frame_or_tty='--create-frame'
                OPTIND+=1
                shift
                ;;

            # Emacs option `--debug-init'.
            --de*|-de*)
                argv[argc++]=$1
                OPTIND+=1
                shift

                enable_trace='true'
                trap ': Line \#"$LINENO"' debug
                set -x

                # Emacs-specific argument, so invoke Emacs.
                _EMACSCLIENT_CMD=$_EMACS_CMD
                ;;

            # Emacs/emacsclient option `--eval'.
            --ex*|-ex*|--ev*|-ev*)
                argv[argc++]=$1
                argv[argc++]=$2
                OPTIND+=$(( $# == 1 ? 1 : 2 ))
                shift $(( $# == 1 ? 1 : 2 ))

                # Run in foreground.
                background_op=''
                ;;

            # Emacs option `--visit FILE'.
            --fi*|-fi*|--vi*|-vi*)
                argv[argc++]='--eval'

                # FILE given as --visit=FILE
                if [[ ."$1" =~ \.[^=]*=(.*) ]]; then
                    file=${BASH_REMATCH[1]}
                    OPTIND+=1
                    shift

                # FILE given as second, possibly null, argument.
                else
                    file=$2
                    OPTIND+=$(( $# == 1 ? 1 : 2 ))
                    shift $(( $# == 1 ? 1 : 2 ))
                fi

                argv[argc]='(find-file "'
                argv[argc]+=$file
                argv[argc++]+='")'
                ;;

            # emacsclient option `--frame'
            --fr*|-fr*|-F)
                # OPTARG given as --opt=OPTARG.
                if [[ ."$1" =~ \.([^=]*)=(.*) ]]; then
                    argv[argc++]=${BASH_REMATCH[1]}
                    argv[argc++]=${BASH_REMATCH[2]}
                    OPTIND+=1
                    shift

                # OPTARG given as second, possibly null, argument.
                else
                    argv[argc++]=$1
                    argv[argc++]=$2
                    OPTIND+=$(( $# == 1 ? 1 : 2 ))
                    shift $(( $# == 1 ? 1 : 2 ))
                fi
                ;;

            # Print usage, then return.
            --h*|-h*)
                usage
                return 1
                ;;

            # Emacs option `--insert FILE'.
            # NB: This command only makes sense if the current buffer is
            #     set, e.g.:
            #
            #         $ em --visit file1 --insert file2
            #
            #     or
            #
            #         $ em --buffer '*scratch*' --insert file
            #
            --in*|-in*)
                argv[argc++]='--eval'

                # FILE given as --insert=FILE
                if [[ ."$1" =~ \.[^=]*=(.*) ]]; then
                    file=${BASH_REMATCH[1]}
                    OPTIND+=1
                    shift

                # FILE given as second, possibly null, argument.
                else
                    file=$2
                    OPTIND+=$(( $# == 1 ? 1 : 2 ))
                    shift $(( $# == 1 ? 1 : 2 ))
                fi

                argv[argc]='(insert-file-contents "'
                argv[argc]+=$(printf '%q' "$file")
                argv[argc++]+='" nil nil nil nil)'
                ;;

            # Extended Emacs option `--kill'.
            --k*|-k*)
                argv[argc++]='--eval'

                # ARG given as --kill=ARG
                if [[ ."$1" =~ \.[^=]*=(.*) ]]; then
                    kbinput=${BASH_REMATCH[1]}
                    OPTIND+=1
                    shift

                # ARG given as second, possibly null, argument.
                else
                    kbinput=$2
                    OPTIND+=$(( $# == 1 ? 1 : 2 ))
                    shift $(( $# == 1 ? 1 : 2 ))
                fi

                argv[argc]='(kill-emacs '
                argv[argc]+=${kbinput:-0}
                argv[argc++]+=')'
                allow_server_start='false'
                emacs_verify_kill='true'
                ;;

            # emacsclient option `-t' shadows Emacs short `--terminal' option.
            --tt*|-tt*|-nw|-t)
                preload_files='false'
                create_new_frames='false'
                create_many_new_frames='false'
                frame_or_tty='-nw'
                OPTIND+=1
                shift

                # Run in foreground.
                background_op=''
                ;;

            -V|--version)
                $ED_CMD - <<EOF
r !"$_EMACSCLIENT_CMD" --version
s/[[:space:]]\{1,\}/ and GNU Emacs front end /p
q
EOF
                return 1
                ;;

            +[0-9]*|-*)
                argv[argc++]=$1
                OPTIND+=1
                shift
                ;;

            *)
                break
                ;;
        esac

        # No more arguments?
        if (( $# == 0 )); then
            break
        fi
    done

    if test ."$server_name" = .'' -a ."$_EMACSCLIENT_CMD" != ."$_EMACS_CMD"; then
        server_name=server_${user_name}
        argv[argc++]='-s'
        argv[argc++]=$server_name
    fi
}

if test ."$0" = ."${BASH_SOURCE[0]}"; then
    declare script=$(resolve-existing "$0")
    declare script_name=${script##*/}
    declare script_dir=${script%/*}
    declare emacs_confdir=${HOME}/.emacs.d

    # Delay in seconds while buffer loads (system dependent).
    declare until_buffer_loads=0.5

    # Initialize options
    declare -a argv=()
    declare -a argx=()
    declare allow_server_start=true
    declare argc=0
    declare background_op='&'
    declare create_many_new_frames=false
    declare create_new_frames=false
    declare enable_trace=false
    declare frame_or_tty=--create-frame
    declare preload_files=false
    declare server_name=''
    declare sudo_user=''
    declare sudo_user_prefix=''
    declare tty_name=$($TTY_CMD)
    declare user_name=$($ID_CMD -un)
    declare -i user_id=$($ID_CMD -u)

    # If evaling `(save-buffers-kill-emacs)' times out, then send SIGKILL.
    declare emacs_verify_kill=false
    declare emacs_kill_timeout=3

    # Default error message.
    declare error_diagnostic='Failed to connect to server.
To start the server in Emacs, type "M-x server-start".'


    # If no arguments, then edit buffer `*scratch*' by default
    if (( $# == 0 )); then
        set -- --buffer='*scratch*'
    fi

    # SSH session.
    if test ."$SSH_TTY" != .''; then
        declare -a endpoint=( $SSH_CONNECTION )

        # Client and server IPs differ...
        if test ."${endpoint[0]}" != ."${endpoint[2]}"; then
            configure-for-console
            if test ."$_EMACSCLIENT_CMD" != ."$_EMACS_CMD"; then
                set -- --socket-name="$server_name" "$@"
            fi
        fi
    fi

    if (( $(tty-owner-id) != user_id )); then

        # Could exec `script', but Emacs daemon wouldn't be accessible
        # after exit, so just call Emacs directly.
        _EMACSCLIENT_CMD=$_EMACS_CMD
        configure-for-console
    elif test ."$server_name" = .'' -a \
              ."$SUDO_USER" != .'' -a \
              ."$SUDO_USER" != "$USER"; then

        #
        configure-for-console
        if test ."$_EMACSCLIENT_CMD" != ."$_EMACS_CMD"; then
            set -- --socket-name="$server_name" "$@"
        fi
    fi

    # On non-Apple/Microsoft systems, if Wayland and/or X11 display
    # not set, assume running in console.
    case "$($UNAME_CMD)" in
        Darwin|Windows)
        ;;
        *)
            if test ."$server_name" = .'' \
                    -a \( ."$DISPLAY" = .'' -a ."$WAYLAND_DISPLAY" = .'' \); then
                configure-for-console
                if test ."$_EMACSCLIENT_CMD" != ."$_EMACS_CMD"; then
                    set -- --socket-name="$server_name" "$@"
                fi
            fi
            ;;
    esac

    exec 3>&2

    stderr_cache=$($MKTEMP_CMD "${TMPDIR:-/tmp}/emacsclient.XXXXX") || {
        error_diagnostic="Failed to create temp file"
        raise-exception 'mktemp'
    }

    # Only help or version requested.
    OPTIND=1
    if ! parse-options "$@"; then
        exit 0
    fi

    shift $(( OPTIND - 1 ))

    # Ignore emacsclient alternate editor.
    unset ALTERNATE_EDITOR
    # unset EMACS

    # Ensure that Emacs config directory exists for logging.
    if test ! -d "$emacs_confdir"; then
        $MKDIR_CMD -p "$emacs_confdir"
        $TOUCH_CMD "${emacs_confdir}/auto-insert.el"
    fi

    trap 'test -f "$stderr_cache" && $RM_CMD -f "$stderr_cache"; exit $error_status' 0 1 2 15

    # $enable_trace || exec 1>/dev/null 2>"$stderr_cache"
    $enable_trace || exec 2>"$stderr_cache"

    if test ."$_EMACSCLIENT_CMD" = ."$_EMACS_CMD"; then
        switch-to-emacs
    elif $allow_server_start && ! is-running-emacs; then
        start-emacs-server
    fi

    # Sequentially open files...
    if ! $preload_files; then

        if test -n "$(echo ${argv[@]})" -o -n "$(echo $@)"; then
            i=0
            for f in "$@"; do
                if [[ ."$f" =~ ^\.(.*):([0-9]+)$ ]]; then
                    argv+=( "+${BASH_REMATCH[2]}" )
                    f=${BASH_REMATCH[1]}
                fi
                if [[ ! ."$f" =~ ^\./ ]]; then
                    argx[i++]="${sudo_user_prefix}$PWD/$f"
                else
                    argx[i++]="${sudo_user_prefix}$f"
                fi
            done
            eval '{
            "$_EMACSCLIENT_CMD" $(create-frame-or-tty)                        \
                            ${argv[0]:+"${argv[@]}"}                          \
                            ${argx[0]:+"${argx[@]}"} ||
            raise-exception sequence
        }' $background_op
            $SLEEP_CMD $until_buffer_loads
        fi

        # Simultaneously open files...
    else

        # each in new frame
        if $create_many_new_frames; then
            i=0
            for f in "$@"; do
                if [[ ."$f" =~ ^\.(.*):([0-9]+)$ ]]; then
                    argv+=( "+${BASH_REMATCH[2]}" )
                    f=${BASH_REMATCH[1]}
                fi
                if [[ ! ."$f" =~ ^\./ ]]; then
                    argx="${sudo_user_prefix}$PWD/$f"
                else
                    argx="${sudo_user_prefix}$f"
                fi
                eval '{
                "$_EMACSCLIENT_CMD" $(create-frame-or-tty)                    \
                            ${argv[0]:+"${argv[@]}"}                          \
                            ${argx[0]:+"${argx[@]}"} ||
                raise-exception many frames
            }' $background_op
                $SLEEP_CMD $until_buffer_loads
            done
        else
            for f in "$@"; do
                if [[ ."$f" =~ ^\.(.*):([0-9]+)$ ]]; then
                    argv+=( "+${BASH_REMATCH[2]}" )
                    f=${BASH_REMATCH[1]}
                fi
                if [[ ! ."$f" =~ ^\./ ]]; then
                    argx="${sudo_user_prefix}$PWD/$f"
                else
                    argx="${sudo_user_prefix}$f"
                fi
                eval '{
                "$_EMACSCLIENT_CMD" $(create-frame-or-tty)                    \
                            ${argv[0]:+"${argv[@]}"}                          \
                            ${argx[0]:+"${argx[@]}"} ||
                raise-exception preload
            }' $background_op
                $SLEEP_CMD $until_buffer_loads
                create_new_frames='false'
            done
        fi

        # No file args...
        if (( $# == 0 )); then
            eval '{
                "$_EMACSCLIENT_CMD" $(create-frame-or-tty)                    \
                            ${argv[0]:+"${argv[@]}"} ||
                raise-exception no file args
            }' $background_op
        fi
    fi

    if test ."$background_op" != .''; then
        if test -x "$WMCTRL_CMD"; then
            if $WMCTRL_CMD -l | $GREP_CMD -q 'emacs@'; then
                $WMCTRL_CMD -a 'emacs@'
            else
                eval $WMCTRL_CMD ${1:+"-a ${1##*/}"}
            fi
        elif test -x "$OSASCRIPT_CMD"; then
            emacs_frontmost='tell application "System Events" '
            emacs_frontmost+='to set frontmost of process "Emacs" to true'
            $OSASCRIPT_CMD -e "$emacs_frontmost"
        fi

        # Append newline after "Waiting for Emacs..."
        $allow_server_start && echo >&3
    fi

    if $emacs_verify_kill; then
        echo "Stopping Server..." >&3
        $SLEEP_CMD $emacs_kill_timeout
        case "$OSTYPE" in
            darwin*)
                $PKILL_CMD -9 -u "$user_id" -f                                   \
                           "${_EMACS_CMD##*/}.*daemon=.*${server_name} "
                ;;
            *)
                $PKILL_CMD -9 -u "$user_id" -f                                   \
                           "${_EMACS_CMD##*/}.*daemon=.*${server_name}\\b"
                ;;
        esac
    fi
fi
